//
// Module CatRecognizer2020_lib.MAC
//
// Created:
//          by - eshelga.UNKNOWN (L118W111)
//          at - 22:34:13 12/26/2019
//
// Generated by Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
//

`resetall
`timescale 1ns/10ps
`include "params.v"
module MAC( 
  // Port Declarations
  input   wire                                                                                  clk,//input
  input   wire                                                                                  rst,//input
  input   wire                                                                                  start_work,//input
  input   wire  signed  [`WEIGHT_BIAS_PRECISION-`ONE_bit:0]                                     bias, //input

  input   wire          [`PIXEL_PRECISION*`NUMBER_OF_PIXELS-`ONE_bit:0]                         pixdata, //input

  input   wire  signed  [`WEIGHT_BIAS_PRECISION*`NUMBER_OF_PIXELS-`ONE_bit:0]                   weights,//input
  output  reg                                                                                   mac_done,//output
  output  reg   signed  [`PIXEL_PRECISION+`WEIGHT_BIAS_PRECISION+1:0]                    mac_out, //output
  output  reg                                                                                   over_flow//output
  );
  
  wire signed   [`PIXEL_PRECISION+`WEIGHT_BIAS_PRECISION+1:0]mult_out_array[`NUMBER_OF_PIXELS-`ONE_bit:0];    //pixel data*weights array
  
  wire signed   [`PIXEL_PRECISION+`WEIGHT_BIAS_PRECISION+1:0]sum[`NUMBER_OF_PIXELS-`ONE_bit:0];      //the adders output wires
  wire [`NUMBER_OF_PIXELS-`ONE_bit:0]c ;                                                             //the carry wires
  wire[`PIXEL_PRECISION+`WEIGHT_BIAS_PRECISION+1:0] bias_padded;                                   //sign extended bias
  reg [`AMBA_WORD:0]count_delay; // count
  //wire signed [`PIXEL_PRECISION*`NUMBER_OF_PIXELS:0] temp;
  
  
  //bias sign extention to the adder size
  assign bias_padded = (bias[`WEIGHT_BIAS_PRECISION-1]) ? {{(`PIXEL_PRECISION+2){1'b1}},bias} : {{(`PIXEL_PRECISION+2){1'b0}},bias};
  
  genvar i; //the main gen loop index
  //generate the multiplexers array
  generate
    for (i=1;
          i <= `NUMBER_OF_PIXELS;
          i = i+1)
    begin:generate_multiplier_array
      wire signed [`PIXEL_PRECISION:0]extended_pix;//  extender wires
      wire signed[`WEIGHT_BIAS_PRECISION:0]extended_weight; //  extender wires
      assign extended_pix = {1'b0,pixdata[`PIXEL_PRECISION*i-1 -: `PIXEL_PRECISION]}; // wire assign
      assign extended_weight = {{(weights[`WEIGHT_BIAS_PRECISION*i-1])},weights[`WEIGHT_BIAS_PRECISION*i-1 -: `WEIGHT_BIAS_PRECISION]};// wire assign
      mult U_multiplier(
      .clk(clk),                //connecting the modul
      .rst(rst),//connecting the modul
      .single_pixel_data(extended_pix),//connecting the modul
      .single_weight_data(extended_weight),//connecting the modul
      .mult_out(mult_out_array[i-1])//connecting the modul
      );
    end
  endgenerate
  
  //generate the first level of adders struct
  generate
    for( i =  0;
          i < `NUMBER_OF_PIXELS/2;
          i = i+1 )
    begin:first_adder_lvl
      adder U_addition_s(
      .clk(clk),//connecting the modul
      .rst(rst),//connecting the modul
      .a(mult_out_array[2*i]),//connecting the modul
      .b(mult_out_array[2*i+1]),//connecting the modul
      .sum(sum[i]),//connecting the modul
      .c(c[i])//connecting the modul
      );
    end
  endgenerate
  
  //the level of gen loop index
  genvar j;
  //generate the other levels of adders struct (for R-G-B)
  generate
    for (j = `NUMBER_OF_PIXELS/2;// j is the number of inputs to all the adders at this level
          j > 3;
          j = j/2)
    begin:adder_lvl
      for( i = 1;   //i is the adder number at this level
            i < j;
            i = i + 2 )
      begin:adder_index
        adder U_addition_s(
        .clk(clk),//connecting the modul
        .rst(rst),//connecting the modul
        .a(sum[i-1+`NUMBER_OF_PIXELS-2*j]),//connecting the modul
        .b(sum[i+`NUMBER_OF_PIXELS-2*j]),//connecting the modul
        .sum(sum[((i+1)/2)-1+`NUMBER_OF_PIXELS-j]),//connecting the modul
        .c(c[((i+1)/2)-1+`NUMBER_OF_PIXELS-j])//connecting the modul
        );
      end  
    end
  endgenerate
  
  if (`NUMBER_OF_PIXELS != 8)
  //actions in case of real simulation
  begin:last_adders
    adder U_addition_s_LBNL_RGB(  //last but not least adder
    .clk(clk),//connecting the modul
    .rst(rst),//connecting the modul
    .a(sum[`NUMBER_OF_PIXELS-6]),//connecting the modul
    .b(sum[`NUMBER_OF_PIXELS-5]),//connecting the modul
    .sum(sum[`NUMBER_OF_PIXELS-3]),//connecting the modul
    .c(c[`NUMBER_OF_PIXELS-3])//connecting the modul
    );
    adder U_addition_s_bias_RGB(   //bias adder
    .clk(clk),//connecting the modul
    .rst(rst),//connecting the modul
    .a(sum[`NUMBER_OF_PIXELS-4]),//connecting the modul
    .b(bias_padded),//connecting the modul
    .sum(sum[`NUMBER_OF_PIXELS-2]),//connecting the modul
    .c(c[`NUMBER_OF_PIXELS-2])//connecting the modul
    );
    adder U_addition_s_final_RGB( //final adder
    .clk(clk),//connecting the modul
    .rst(rst),//connecting the modul
    .a(sum[`NUMBER_OF_PIXELS-3]),//connecting the modul
    .b(sum[`NUMBER_OF_PIXELS-2]),//connecting the modul
    .sum(sum[`NUMBER_OF_PIXELS-1]),//connecting the modul
    .c(c[`NUMBER_OF_PIXELS-1])//connecting the modul
    );
  end
  //actions in case of 8 pixel simulation
  else
  begin:last_adders8
    adder U_addition_s_final_ver( //final adder
    .clk(clk),
    .rst(rst),
    .a(sum[`NUMBER_OF_PIXELS-4]),
    .b(sum[`NUMBER_OF_PIXELS-3]),
    .sum(sum[`NUMBER_OF_PIXELS-2]),
    .c(c[`NUMBER_OF_PIXELS-2])
    );
    adder U_addition_s_bias_ver(     //bias adder
    .clk(clk),
    .rst(rst),
    .a(sum[`NUMBER_OF_PIXELS-2]),
    .b(bias_padded),
    .sum(sum[`NUMBER_OF_PIXELS-1]),
    .c(c[`NUMBER_OF_PIXELS-1])
    );
  end
  
  
  
  //main proc
  always@(
  posedge clk,
  negedge rst)
  begin: result_driving_proc
    if (!rst) //initialize the registers 
    begin
      mac_done <= 0; //initialize the register
      mac_out <= 0;//initialize the registers
      over_flow <= 0;//initialize the registers
      count_delay <= `mac_delay + 2;//initialize the registers
    end
    else if (start_work & !mac_done)
    begin
      if((count_delay == 0 && `NUMBER_OF_PIXELS == 8) || (count_delay == 1 && `NUMBER_OF_PIXELS != 8))
      begin
        mac_out <= sum[`NUMBER_OF_PIXELS-1];
        over_flow <= (c == 0) ? 0 : 1;
        mac_done <= 1;
        count_delay <= `mac_delay + 4;
      end
      else
        count_delay <= count_delay-1;
    end
    else
      mac_done <= 0;
  end
  
endmodule